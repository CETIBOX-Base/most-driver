
		MOST Device Configuration
		<christian.gromm@microchip.com>


		Chapter 1: Exported Device Information

The MOST core Linux driver supports dynamic configuration via sysfs by exporting
interface specific information to user space. If a first MOST device (mdev) has
attached via a peripherial interface, like USB, PCIe, I2C or MediaLB, the core
generates the new device class <most> and populates the directory
/sys/devices/virtual/most/ with the device information. Every additional device
that attaches will end up in this directory too.
The core will name the first parent device <mdev0>, the second <mdev1> and so on.
A directory of a device has -next to the default files dev, power, subsystem,
device, driver and uevent- the following read only (ro) ASCII attribute entries:

	- product (ro)
	- interface (ro)
	- num_channels (ro)

The attribute files are in ASCII format and hold vendor specificinformation
about the gadget. For instance a `cat product` will reveal the name of the
product. In case of an USB INIC it will return <OS81118>. A `cat interface` will
reveal the name of the interface via which the device is attached to the kernel.
Again, in case of an USB INIC it will return <usb>. A `cat num_channels` will
reveal the number of channels the device exports for communication. Again, in
case of an USB INIC that has 8 USB endpoints active it will return <8>.

For each channel the device exports a directory is created that meets the
following naming convention:

	<parent_dir><-ch${number}>[<info tag>]

First part of the name will be the parent device this channels belongs to.
Second would be the characters "-ch" followed by the actual channel number.
Last part would be an optional info tag that might or might not be used. In
case of device that is attached via USB, the optional info tag field would be
the USB endpoint address this channel is bound to.
In case of the USB INIC example from above -as a second most device- these
directories would be

	- mdev1-ch0@ep_81
	- mdev1-ch1@ep_82
	- mdev1-ch2@ep_83
	- mdev1-ch3@ep_84
	- mdev1-ch4@ep_0c
	- mdev1-ch5@ep_0d
	- mdev1-ch6@ep_0e
	- mdev1-ch7@ep_0f

The same names are used to populate the /dev directory to allow an application
to access the driver.

A channel directory of a device has -next to the default files dev, power,
subsystem, device, driver and uevent- the following ASCII attribute entries:

	- available_datatypes (ro)
	- available_directions (ro)
	- number_of_packet_buffers (ro)
	- number_of_stream_buffers (ro)
	- size_of_packet_buffer (ro)
	- size_of_stream_buffer (ro)
	- set_direction (rw)
	- set_datatype (rw)
	- channel_enabled (rw)

Appliations use these files to learn about the attached devices they want
to talk to. Like `cat available_datatypes` would reveal all datatypes this
channel can transport, `cat available_directions` would reveal the supported
directions, `cat number_of_packet_buffers` would reveal the number of buffers
the channel uses to transport packet data and `cat size_of_packet_buffer` would
reveal the size of a single packet buffer. The latter two are the same for
streaming data. The attribute files set_direction, set_datatypes and
channel_enabled are for configuring purposes (see chapter 2).

Following is an example directory of a system that has two MOST devices
attached. The first product is a "MediaLB USB Bridge" with 6 channels and the
second is an USB INIC with 8 channels. (To keep clarity only the first two
channels of each device are unfold.)

chris@muaddib:/sys/devices/virtual/most$ tree
.
├── mdev0
│   ├── interface
│   ├── mdev0-ch0@ep_81
│   │   ├── available_datatypes
│   │   ├── available_directions
│   │   ├── channel_enabled
│   │   ├── dev
│   │   ├── device -> ../../mdev0
│   │   ├── driver -> ../../../../../bus/most/drivers/mostcore
│   │   ├── number_of_packet_buffers
│   │   ├── number_of_stream_buffers
│   │   ├── power
│   │   ├── set_datatype
│   │   ├── set_direction
│   │   ├── size_of_packet_buffer
│   │   ├── size_of_stream_buffer
│   │   ├── subsystem -> ../../../../../class/most
│   │   └── uevent
│   ├── mdev0-ch1@ep_02
│   │   ├── available_datatypes
│   │   ├── available_directions
│   │   ├── channel_enabled
│   │   ├── dev
│   │   ├── device -> ../../mdev0
│   │   ├── driver -> ../../../../../bus/most/drivers/mostcore
│   │   ├── number_of_packet_buffers
│   │   ├── number_of_stream_buffers
│   │   ├── power
│   │   ├── set_datatype
│   │   ├── set_direction
│   │   ├── size_of_packet_buffer
│   │   ├── size_of_stream_buffer
│   │   ├── subsystem -> ../../../../../class/most
│   │   └── uevent
│   ├── mdev0-ch2@ep_83
│   │		...
│   ├── mdev0-ch3@ep_04
│   │		...
│   ├── mdev0-ch4@ep_85
│   │		...
│   ├── mdev0-ch5@ep_06
│   │		...
│   ├── num_channels
│   ├── power
│   ├── product
│   ├── subsystem -> ../../../../class/most
│   └── uevent
└── mdev1
    ├── interface
    ├── mdev1-ch0@ep_81
    │   ├── available_datatypes
    │   ├── available_directions
    │   ├── channel_enabled
    │   ├── dev
    │   ├── device -> ../../mdev1
    │   ├── driver -> ../../../../../bus/most/drivers/mostcore
    │   ├── number_of_packet_buffers
    │   ├── number_of_stream_buffers
    │   ├── power
    │   ├── set_datatype
    │   ├── set_direction
    │   ├── size_of_packet_buffer
    │   ├── size_of_stream_buffer
    │   ├── subsystem -> ../../../../../class/most
    │   └── uevent
    ├── mdev1-ch1@ep_82
    │   ├── available_datatypes
    │   ├── available_directions
    │   ├── channel_enabled
    │   ├── dev
    │   ├── device -> ../../mdev1
    │   ├── driver -> ../../../../../bus/most/drivers/mostcore
    │   ├── number_of_packet_buffers
    │   ├── number_of_stream_buffers
    │   ├── power
    │   ├── set_datatype
    │   ├── set_direction
    │   ├── size_of_packet_buffer
    │   ├── size_of_stream_buffer
    │   ├── subsystem -> ../../../../../class/most
    │   └── uevent
    ├── mdev1-ch2@ep_83
    │		...
    ├── mdev1-ch3@ep_84
    │		...
    ├── mdev1-ch4@ep_0c
    │		...
    ├── mdev1-ch5@ep_0d
    │		...
    ├── mdev1-ch6@ep_0e
    │		...
    ├── mdev1-ch7@ep_0f
    │		...
    ├── num_channels
    ├── power
    ├── product
    ├── subsystem -> ../../../../class/most
    └── uevent



		Chapter 2: The configuration

Unlike the static version of the Linux core driver, the dynamic version of the
core will not grant any access to the driver through the /dev directory unless
the underlying device has been properly configured by the user. To configure a
device and make it ready for communication the application needs to write the
files set_direction, set_datatype and channel_enabled. To set the desired
direction of the channel the application writes one of the following strings:

	'dir_tx' or 'dir_rx'

into the attribute file set_direction. This can easily be done by using the
`echo` shell command. No other entry will be accepted by the driver. To set the
desired data type of the channel the application writes one of the following
strings:

	'control', 'async', 'sync' or 'isoc_avp'

into the attribute file set_datatype. No other entry will be accepted by the
driver.	Lastly, the application wirtes a '1' to the attribute file
channel_enabled. This will arm and unlock the channel in the /dev directory, so
an application can issue an open() syscall. To doublecheck the configuration
user can read back the files previoulsy written.

If the user has no knowledge in advance about what kind of data a channel can
transport or and in what direction it can be used, he may want to parse every
channel directory (see chapter 1) of the device it wants to use and collect the
information of what the channel is capable of.



		Chapter 3: The config_mdev.pl script

To give the user the convenience of _not_ having to parse the sysfs filesystem
and gather all the information about specific device and its channels there is
a Perl script available, which does the job. The script expects two command line
arguments. The first would be the name of a configuration file and the second
would be the name of the device to be configured. The config file does not
necessarily has to match a specific naming convention, but you might want to
choose a name so others can make a good guess on what it is suppossed to do.
So, a recommendation would be

	mdev${devno}.conf

So, if we would like to generate a config file for the USB INIC from the above
example, the file's name would be

	mdev1.conf

The structure of the config file is rather simple and does not seek to win
any "coolness" or "what-a-hell-of-a-config-file" awards. The beauty of the
concept is its simplicity. It starts with a start identyfier, followed by one
or more channel sections that are terminated by an end identyfier. That's it. A
config file <mdev1.conf> to configure the example USB INIC would look like this:

[mdev_conf:start]

[ Channel 0 ]
direction	dir_rx
datatype	control

[ Channel 1 ]
direction	dir_rx
datatype	sync

[ Channel 2 ]
direction	dir_rx
datatype	isoc_avp

[ Channel 3 ]
direction	dir_rx
datatype	async

[ Channel 4 ]
direction	dir_tx
datatype	control

[ Channel 5 ]
direction	dir_tx
datatype	sync

[ Channel 6 ]
direction	dir_tx
datatype	isoc_avp

[ Channel 7 ]
direction	dir_tx
datatype	async

[mdev_conf:end]

Example:
To let the script configure the eight channels of the above USB INIC you would
call the script like this;

chris@muaddib:./config_mdev.pl mdev1.conf mdev1

Advice of the author: the script is written pretty much straight forward and
assumes that you _know_ what you are doing. No cross-checking is done on
whether or not the device you're trying to configure matches the sections of the
config file used for configuration. So _be_ sure, you are using the right file
for right device.







